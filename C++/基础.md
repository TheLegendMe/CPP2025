一,c/c++基础
1.描述c++程序的内存由哪几个部分组成，每个区域分别有什么特点和作用。
栈区：栈区上的数据是一般的数据定义的，比如说函数的参数值，局部变量的值。离开作用域就会销毁。
堆区：动态内存分配，一般是new/malloc申请的内存，容量比较大适合存放一些比较大内存数据
全局静态区：全局变量和static关键字定义的，共享的数据
常量区：const存放常量的比如说常量字符串
代码区：用户执行程序的的区域吗，由用户自己定义的区域,用来存放函数体。

2.什么时候分配内存会 产生内存碎片
动态内存分配和释放：当程序反复申请和释放不同大小的内存块时，会导致空闲内存空间变得不连续，形成内存碎片。
内存分配算法的影响：使用first-fit或best-fit等算法时，容易导致小块内存碎片的累积。
固定大小分配：如果系统只允许固定大小的内存块分配，而应用需要的内存大小各不相同，会导致内部碎片。
内存碎片分为内部碎片和外部碎片
内部碎片是指在程序运行时没有利用到的内存
外部碎片是指在没有分配合理的内存空间，可以一般避免外部碎片的方式是用几个算法实现的

3，负数的编码方式是什么,简述一下他的原理。
负数的编码方式主要有三种：原码、反码和补码，其中补码是现代计算机系统中最常用的表示方法。
负数是用有一串二进制的数，如果第一位是1，那么这个数的一个负数，如果这个数是0，就是正，所以在负数中的运算要看进位
补码使得加法运算统一：可以用同一个加法器处理正数和负数
补码消除了零的双重表示问题：在补码系统中，0只有一种表示方式
补码计算简便：两个数的补码相加，舍去溢出位后就是结果的补码

4，浮点数的编码方式是什么，简述一下他的原理。
浮点数的编码主要基于IEEE 754标准，是计算机表示实数的一种方式。IEEE 754浮点数由三部分组成：符号位、指数位和尾数位。

5，可执行程序是如何生成的？
预处理：加载如#include #define #ifdef 展开宏定义 移除注释
编译：将预处理后的源代码转装换成汇编语言
汇编：将代码转换成机器语言
链接：将多个目标文件合并成一个可执行文件
加载：从操作系统加载到内存，开始执行

6,可执行程序是如何变成进程的？
7,C语言中如何调用C++函数
8,重写  重载 和重定义如和区别
9,66


**网盘话术1.0**

私有云数据管理网盘系统，是一个简易的客户对文件进行上传和管理的系统，因为刚转的开发岗位,没有一开始就工作， 而是差不多花了2个月的时间学习完了C++,接着就被领导安排去做了这么一个项目去练手。这个是我自己一个人做。基于linux平台开发，使用线程池与10多路复用技术进行项目搭建。功能效果已经在简历.上展现出来了，他并不关心你实现了什么，而是关心你实现的过程怎样的。

1.框架:服务端父进程fork-个 子进程，父进程负责监听退出消息;子进程专门负责业务操作，内部创建多个线程组成线程池。子进程接收客户的任务,将放入到任务队列中。线程池中凡有空闲的线程就会从这个任务队列中拿取进行任务操作。服务端子进程首先监听网络连接,如果有客户连接，那将成功连 接的socket对象加入到任务队列中。使用epoll技术， 对任务队列中的socket对象进行监听,若监听到准备就绪的事件，会安排线程去处理就绪事件。

2、虚拟文件系统:用一个char类型数组维护客户的当前工作目录， 用mysql记录用户的工作目录的内容信息生成文件表。文件表中的字段有Nodeid.文件路径、文件类型(目录文件还是其他文件)、文件名、客户名、上级目录Nodeid、 文件状态。用户的每个操作都影响着用户自己文件表内容，put时就先可以举具体命令的操作来怎么更新文件表内容的例子。

3、启动客户端连接服务端后，会提示进行账号的登录或注册。客户进行账号注册，将客户名与密码发送给服务端。服务端接收后会去检查本地客户表的信息，若检查无重名的，会随机生成一个盐值， 将盐值与密码进行组合加密存储到客户表密码字段，并将盐值返回给客户端存储。当客户登录时，客户端将盐 值与密码二次加密发送给服务端，服务端接收密码与客户表中的密码做匹配，匹配成功可以允许服务(密码校验函数, crypt) 。

同时对于首次登录成功的客户，服务端会调用加密函数，根据客户名生成一个TOKEN, 返回给客户端，之后客户端方在进行发送消息时，必须连同TOKEN-起发送。如果有人假冒客户，在没有TOKEN的情况下，无法做任何操作。然后服务端接收客户端消息后，再次调用加密函数传入客户名计算出TOKEN与 客户端传来的TOKEN做比较，检查TOKEN是否-致，一致就确定 是真正的用户。

4、客户使用get或put命令实现文件的上传下载，传输数据时以字节流方式传输，使用的小火车传输协议(先发送数据长度，再发送数据内容)，小火车解决的是粘包问题(消息与消息之间缺少边界)。客户端先计算文件的md5值发送给服务端，服务端查找文件表文件md5值，表里存在就秒传。不存在,服务端就先接收文件的md5值，再接收客户端发来的文件数据。若客户端上传文件结束,服务端根据接收的文件内容计算md5值与先前接收的md5值作比较,若相等则文件上传完整正确。超过100M的文件之间调用mmap函数实现零拷贝数据传输。下载文件也是一样的原理。

MSG_ WAITALL:在使用recy()函数和recvfrom()函数时， 如果不指定MSG. _WAITALL标志，则函数可能会在接收到部分数据后就返回，此时需要多次调用函 数才能完整地接收数据。而如果指定了MSG _WAITALL标志，则函数会一直等待， 直到接收到完整的请求数据后才返回，这可以减少调用次数，提高程序效 率。解决了半包问题。计算md5, mg5sum。

```c++
1 int socket(int domain, int type, int protoco1);

2 //domin 使用的协议族信息，AF_ INET ipv4地址族

3 //type 数据传输方式信息， SOCK_ STREAM 数据传输方式是字 节流

4  //protoco1数据传输控制协议IPPROTO_ _TCP，一 般写0、因为前2个参数即可确定但三个参数
```

5、长短命令分离:实现gets 与puts命令与其他命令分离,瞬间响应命令由主线程负责，上传下载命令由子线程负责。所以客户端在连接服务端后,如果客 户发送的是长命令就启动一个新线程时,携带TOKEN实现服务器的认证连接(l8w8jwt 第三方库)

6、超时断开:将服务端里的任务队列变为循环队列，每一个队列元素是一 个集合， 每个集合里存放的都是同一时间内响应的通信句柄。系统要处理的就是 将新连接的socket对象存放在某-时间下的集合里，改变响应的旧socket对象的位置。 假设循环队列的长度是30个，都是满的，每过1 s钟都会有已经存在队列30s的socket对象集合超时，被剔除队列。被踢出的socket对象则是服务端要断开的客户端，即客户端超过30s无任何操作，服务方主动断开连接。 实现:维护-个映射表，netfd 映射所在的当前集合，可以用数组。j(当前秒) --→(+ 1)9630下一秒

**引擎话术1.0**

企业知识库资料检索引擎是用C++写的，也是自己在具备了项目代码的经验后独立着手设计的一个系统后端。

1.框架搭建:采用的是Reactor框架模型，Reactor是一 种基于事件驱动的并发模型，常用于实现高并发网络服务。Reactor模型的核心思想是将I/O事件和数据处理分离，通过注册回调函数的方式来实现事件驱动和异步处理。

Reactor模型的工作原理如下:

●应用程序创建-个I/O线程，用于监听网络连接请求，并处理网络事件。

● I/O线程使用select. epoll等I0复用技术监听多个文件描述符,包括监听套接字和已连接套接字。

●当文件描述符上有事件发生时，I/O线程会触发相应的事件回调函数，执行相应的业务逻辑。这些事件包括新连接、数据到达、连接关闭等。

●事件回调函数执行完毕后,将处理结果返回给应用程序，然后继续监听文件描述符上的事件。

2、关键字推荐:根据离线文本文件和停用词集，提取、分词,去重存储到本地，生成词典文件与词索引文件。首先找到本地语料位置,使用读文件流类, 打开本地语料文本文件，读取文件的每一行字符串, 再使用字符串流对一行的字符串进行操作，汉语使用第三方库cppjieba进行切词，记录好词组和词频生 成词典库。再计算UTF- 8编码中一个汉字字符所占用字 节数，统计词典库中汉字数量和出现在词典库中的位置，记录生成索引库。其实使用map容器就能够存储。

客户端传递查询词之后，服务端再从索引之中查找与之相近的候选词,选取到最合适的候选词之后再将其发送给客户端，候选词的选取则使用最小编辑距离 算法，计算候选词与查询词的相似度。a.优先比较最小编辑距离; b.在编辑距离相同的条件下，再比较候选词的词频;词频越大优先选择c.在词频相同的条件下，按索引表顺序比较候选词;接着获取k个(例如3个或者5个)候选词，返回给客户端。(需要使用优先级队列)

最小编辑算法:是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括替换字符、插入字符、删除字符。- 般来说，编辑距离越小，两个串的相似度越大。

发送给客户端的数据采用的是JSON数据格式封包。选择的是nlohmann/json开源库。

3、知识库资料推荐:知识库资料都是xml文件,首先找到本地知识库资料xml文件,使用第三方库tinyxml2提取xml文件内容、 使用Simhash第 三方库对 xml文件中每一篇文章内容进行文本相似度计算，即simhash值， 若根据两篇文章的simhash值得出汉明距离，距离小规定的汉明距离阈值则判定相似。以此将相似的文章进行去重然后存放于容器中。接着再对容器中的资料文章进行重新编排,重新格式化文章结构,格式编排为即文章id.文章链接、文章标题、文章内容保存于本地生成资料库。由于文章数量比较多，再生成一个资料索引文件,保存资料库中文章的具体位置以及文章内容长度，方便具体定位资料库的某篇文章。最后-步就是根据检索词推荐包含检索词的资料文章，使用的TF-IDF算法。

TF : Term Frequency,某个词在文章中出现的次数/文章的总次数; DF: Document Frequency,某个词在所有文章中出现的次数，即包含该词语的文档数 量; IDF: Inverse Document Frequency,逆文档频率，表示该词对于该篇文章的重要性的一个系数，其计算公式为: IDF = log2(N/(DF+1)),其中N表示文 档总数计算词语在这一篇文章中的权重 w则为: w= TF*IDF由于-篇文档包含多 个词语W,..w.n还需要对这些词语的权重系数进行归- -化处理, 其计算公式如下: W' = w /sqrt(W1^2 + w2^2 +..+ wn^2)词语权重比，上该篇文章所有的词语权重平方的和再开方。

最后得到一个倒排索引的数据结构，所有文章中的词语放在集合里，该集合里的每个元索映射该词语出现的文章id与权重的集合，生成一个倒排索引库存储。

4、资料推荐的查询策略:

(1)在处理查询请求时，对于查询的关键词,将它们视为-篇文档X,通过TF-IDF 算法计算出每个关键词的权重系数;

```
将其组成一个向量X = (x1, x2，.... xn)，该向量作为基准向量Base;
```

(2)通过倒排索引表去查找包含所有关键字的资料文章;只要其中有一个查询词不在倒排索引表中，就认为没有找到相关的资料;

(3)如果找到了资料文章,则需要对查找到的资料文章进行排序。排序算法采用余弦相似度。既然查找到的资料文章都包含查询词,那么获取每个查询词 的w权重,将它们组成一个向量Y = (y1,y2, .. yn),用该向量代表这篇资料文章，该向量Y是资料文章的特征。

(4)然后计算它与基准向量Base的余弦值，该余弦值代表的就是Y与X的相似度;那么现在只需要将查找到的所有资料文章都与X进行余弦相似度cosθ 的计算,然后根据cos0的大小进行排序, cosθ越大越相似，这样的资料文章应该出现在前排的位置。

cosθ的计算方法如下:

X*Y=(X1 *y1 +x2*y2+ x3*y3)

cosθ =(X*Y)/(|X|* |Y|)

(5)当找到资料文件之后,还需要提取每篇网页中的标题和摘要信息,然后将这些信息封装成一个JSON字符串，交给服务器框架模块去发送给客户端。要注意的是:摘要信息是根据查询词自动生成的。

5.优化查询模块，提升网页查询效率:使用Redis建立缓存系统

**面试反问1.0**

当面试官问完问题后，程序员可以用反问的方式来进一步表达自 己的思考和了解更多关于公司和职位的信息。

1.公司的核心产品或部门是什么?

2.您能介绍下咱们部门]的整体架构吗?分为多少个层级?

3.您能介绍下您的工作履历吗,工作背景，我想更多的了解一下您?

4.我们部门工作的主要挑战是什么?您工作的主要挑战是什么? (会说一下公司的情况)

5.如果我进入到公司之后，会分配到哪个项目组呢?

6.项目组的情况，主要是做什么?会用到哪些技术栈?

7.公司里用的技术栈有哪些，我可以提取准备一下

8.要一下面试官的联系方式，微信(有机会问一下面试情况，有没有机会下一-面, 提一些面试问题) 

9."您希望新员工在加入公司后的前三个月内完成哪些任务?”

10. "公司对员工的培训和发展计划有哪些?

11. "您能否分享一些公司的项目 或产品的信息?”

12. "公司的工作时间和工作制度是怎样的?'

13. "公司对员工的反馈和评估是如何进行的?”

14. "公司对员工的福利和福利计划有哪些?”

15. "公司的团队规模是多少?”

16.公司的前台联系方式，